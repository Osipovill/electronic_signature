import time

# –ü–∞—Ä–∞–º–µ—Ç—Ä—ã LCG –¥–ª—è 31-–±–∏—Ç–Ω–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏
# –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∏–∑ "Numerical Recipes" - –ø—Ä–æ–≤–µ—Ä–µ–Ω–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –¥–ª—è 31-–±–∏—Ç–Ω–æ–≥–æ LCG
a = 1597
c = 51749
m = 2**31 - 1  # –ò—Å–ø–æ–ª—å–∑—É–µ–º —á–∏—Å–ª–æ –ú–µ—Ä—Å–µ–Ω–Ω–∞ 2^31-1 = 2147483647

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è seed –∑–Ω–∞—á–µ–Ω–∏–µ–º, –∑–∞–≤–∏—Å—è—â–∏–º –æ—Ç –≤—Ä–µ–º–µ–Ω–∏
seed = int(time.time() * 1000) % m

def set_seed(s):
    """–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –Ω–∞—á–∞–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–∞."""
    global seed
    seed = s % m

def my_random():
    """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ª–µ–¥—É—é—â–µ–µ –ø—Å–µ–≤–¥–æ—Å–ª—É—á–∞–π–Ω–æ–µ —á–∏—Å–ª–æ."""
    global seed
    seed = (a * seed + c) % m
    return seed

def my_getrandbits(n):
    """
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ, –ø–æ–ª—É—á–µ–Ω–Ω–æ–µ –ø—É—Ç–µ–º –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ n —Å–ª—É—á–∞–π–Ω—ã—Ö –±–∏—Ç.
    –î–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –Ω–µ—Å–∫–æ–ª—å–∫–æ –≤—ã–∑–æ–≤–æ–≤ my_random().
    """
    result = 0
    bits_per_call = 31  # —á–∏—Å–ª–æ –±–∏—Ç, –≤—ã–¥–∞–≤–∞–µ–º–æ–µ –æ–¥–Ω–∏–º –≤—ã–∑–æ–≤–æ–º my_random()
    calls = (n + bits_per_call - 1) // bits_per_call
    for _ in range(calls):
        # –°–¥–≤–∏–≥–∞–µ–º —É–∂–µ –Ω–∞–±—Ä–∞–Ω–Ω—ã–µ –±–∏—Ç—ã –Ω–∞ 31 –ø–æ–∑–∏—Ü–∏—é –≤–ª–µ–≤–æ
        # –∏ "–¥–æ–±–∞–≤–ª—è–µ–º" –Ω–æ–≤—ã–µ —Å–ª—É—á–∞–π–Ω—ã–µ –±–∏—Ç—ã —á–µ—Ä–µ–∑ –ø–æ–±–∏—Ç–æ–≤–æ–µ –ò–õ–ò
        result = (result << bits_per_call) | my_random()
    # "–û–±—Ä–µ–∑–∞–µ–º" —á–∏—Å–ª–æ, –µ—Å–ª–∏ –≤–¥—Ä—É–≥ –Ω–∞–±—Ä–∞–ª–∏ –ª–∏—à–Ω–∏–µ –±–∏—Ç—ã
    mask = (1 << n) - 1  # –ú–∞—Å–∫–∞ –∏–∑ n –µ–¥–∏–Ω–∏—á–Ω—ã—Ö –±–∏—Ç
    result = result & mask
    return result

def my_randint(a, b):
    """
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ª—É—á–∞–π–Ω–æ–µ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ –∏–∑ –¥–∏–∞–ø–∞–∑–æ–Ω–∞ [a, b] –≤–∫–ª—é—á–∏—Ç–µ–ª—å–Ω–æ.
    –î–ª—è —Ä–∞–≤–Ω–æ–º–µ—Ä–Ω–æ–≥–æ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –º–µ—Ç–æ–¥ –æ—Ç–±–æ—Ä–∞ (rejection sampling).
    """
    import math
    rng = b - a + 1
    bits = math.ceil(math.log2(rng))
    while True:
        r = my_getrandbits(bits)
        if r < rng:
            return a + r

def my_pow(a, b, mod):
    """
    –í—ã—á–∏—Å–ª—è–µ—Ç (a^b) mod —Å –ø–æ–º–æ—â—å—é –∞–ª–≥–æ—Ä–∏—Ç–º–∞ –±—ã—Å—Ç—Ä–æ–≥–æ –≤–æ–∑–≤–µ–¥–µ–Ω–∏—è –≤ —Å—Ç–µ–ø–µ–Ω—å.
    """
    result = 1
    a = a % mod
    while b > 0:
        if b & 1:  # –µ—Å–ª–∏ –º–ª–∞–¥—à–∏–π –±–∏—Ç —Ä–∞–≤–µ–Ω 1
            result = (result * a) % mod
        a = (a * a) % mod
        b //= 2
    return result

# –§—É–Ω–∫—Ü–∏–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –ø—Ä–æ—Å—Ç—ã—Ö —á–∏—Å–µ–ª –∏ RSA-–∫–ª—é—á–µ–π
def is_prime_trial(n):
    """–ü—Ä–æ–≤–µ—Ä–∫–∞ —á–∏—Å–ª–∞ n –Ω–∞ –ø—Ä–æ—Å—Ç–æ—Ç—É –º–µ—Ç–æ–¥–æ–º –ø—Ä–æ–±–Ω–æ–≥–æ –¥–µ–ª–µ–Ω–∏—è."""
    if n < 2:
        return False
    if n % 2 == 0:
        return n == 2
    # –ë—ã—Å—Ç—Ä–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –¥–µ–ª–∏–º–æ—Å—Ç–∏ –º–∞–ª—ã–º–∏ –ø—Ä–æ—Å—Ç—ã–º–∏ —á–∏—Å–ª–∞–º–∏
    small_primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71]
    for p in small_primes:
        if n == p:
            return True
        if n % p == 0:
            return False
    return True

def is_prime_fermat(n, k=5):
    """–ü—Ä–æ–≤–µ—Ä–∫–∞ —á–∏—Å–ª–∞ n –Ω–∞ –ø—Ä–æ—Å—Ç–æ—Ç—É —Å –ø–æ–º–æ—â—å—é —Ç–µ—Å—Ç–∞ –§–µ—Ä–º–∞."""
    if n < 4:
        return n in [2, 3]
    if n % 2 == 0:
        return False
    for _ in range(k):
        a = my_randint(2, n - 2)
        if my_pow(a, n - 1, n) != 1:
            return False
    return True

def generate_prime(bits):
    """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ø—Ä–æ—Å—Ç–æ–≥–æ —á–∏—Å–ª–∞ –∑–∞–¥–∞–Ω–Ω–æ–π –±–∏—Ç–æ–≤–æ–π –¥–ª–∏–Ω—ã."""
    if bits < 2:
        bits = 2
    while True:
        cand = my_getrandbits(bits)
        cand |= (1 << (bits - 1))  # —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å—Ç–∞—Ä—à–∏–π –±–∏—Ç
        cand |= 1                  # –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ–º, —á—Ç–æ —á–∏—Å–ª–æ –Ω–µ—á—ë—Ç–Ω–æ–µ
        if is_prime_trial(cand) and is_prime_fermat(cand):
            return cand

def egcd(a, b):
    """–†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º –ï–≤–∫–ª–∏–¥–∞."""
    if a == 0:
        return b, 0, 1
    gcd_val, x1, y1 = egcd(b % a, a)
    x = y1 - (b // a) * x1
    y = x1
    return gcd_val, x, y

def mod_inverse(e, phi):
    """–ù–∞—Ö–æ–∂–¥–µ–Ω–∏–µ –æ–±—Ä–∞—Ç–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞ e (mod phi), –µ—Å–ª–∏ –æ–Ω —Å—É—â–µ—Å—Ç–≤—É–µ—Ç."""
    gcd_val, x, _ = egcd(e, phi)
    if gcd_val != 1:
        return None
    return x % phi

def generate_rsa_keys(bits=64):
    """
    –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —É–ø—Ä–æ—â—ë–Ω–Ω—ã—Ö RSA-–∫–ª—é—á–µ–π (e, d, n) –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–æ–Ω–Ω—ã—Ö —Ü–µ–ª–µ–π.
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ª–æ–≤–∞—Ä—å —Å –∫–ª—é—á–∞–º–∏.
    """
    p = generate_prime(bits)
    q = generate_prime(bits)
    while q == p:
        q = generate_prime(bits)
    n = p * q
    phi = (p - 1) * (q - 1)
    e = 65537 #  –æ–Ω–æ —É–¥–æ–≤–ª–µ—Ç–≤–æ—Ä—è–µ—Ç —É—Å–ª–æ–≤–∏—é –≤–∑–∞–∏–º–Ω–æ–π –ø—Ä–æ—Å—Ç–æ—Ç—ã —Å —Ñ—É–Ω–∫—Ü–∏–µ–π –≠–π–ª–µ—Ä–∞ ùúô  –¥–ª—è –ø–æ—á—Ç–∏ –≤—Å–µ—Ö –ø–æ–¥—Ö–æ–¥—è—â–∏—Ö –ø—Ä–æ—Å—Ç—ã—Ö —á–∏—Å–µ–ª p –∏ q
    if e >= phi or egcd(e, phi)[0] != 1:
        e = 3
        while e < phi and egcd(e, phi)[0] != 1:
            e += 2
    d = mod_inverse(e, phi)
    return {'public': (e, n), 'private': (d, n), 'p': p, 'q': q, 'phi': phi}

# ---------- –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ ----------
def text_to_int(text):
    """–ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞ –≤ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ (–±–∞–π—Ç—ã big-endian)."""
    return int.from_bytes(text.encode('utf-8'), 'big')

def int_to_text(num):
    """–ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –±–æ–ª—å—à–æ–≥–æ —Ü–µ–ª–æ–≥–æ —á–∏—Å–ª–∞ –æ–±—Ä–∞—Ç–Ω–æ –≤ —Å—Ç—Ä–æ–∫—É (UTF-8)."""
    if num == 0:
        return ""
    length = (num.bit_length() + 7) // 8
    return num.to_bytes(length, 'big').decode('utf-8', errors='ignore')

# ---------- –û—Å–Ω–æ–≤–Ω—ã–µ RSA-—Ñ—É–Ω–∫—Ü–∏–∏ (—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ/–¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ/–ø–æ–¥–ø–∏—Å—å/–ø—Ä–æ–≤–µ—Ä–∫–∞) ----------
def rsa_encrypt(m_int, pubkey):
    """RSA-—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ —á–∏—Å–ª–∞ m_int –æ—Ç–∫—Ä—ã—Ç—ã–º –∫–ª—é—á–æ–º (e, n)."""
    e, n = pubkey
    return my_pow(m_int, e, n)

def rsa_decrypt(c_int, privkey):
    """RSA-—Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ —á–∏—Å–ª–∞ c_int –∑–∞–∫—Ä—ã—Ç—ã–º –∫–ª—é—á–æ–º (d, n)."""
    d, n = privkey
    return my_pow(c_int, d, n)

def rsa_sign(m_int, privkey):
    """RSA-–ø–æ–¥–ø–∏—Å—å —á–∏—Å–ª–∞ m_int –∑–∞–∫—Ä—ã—Ç—ã–º –∫–ª—é—á–æ–º (d, n)."""
    d, n = privkey
    return my_pow(m_int, d, n)

def rsa_verify(m_int, s_int, pubkey):
    """–ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–ø–∏—Å–∏ s_int –¥–ª—è —Å–æ–æ–±—â–µ–Ω–∏—è m_int –æ—Ç–∫—Ä—ã—Ç—ã–º –∫–ª—é—á–æ–º (e, n)."""
    e, n = pubkey
    return m_int % n == my_pow(s_int, e, n)
